local utils = require("codecompanion.utils.util")

return {
  adapters = {
    anthropic = "anthropic",
    ollama = "ollama",
    openai = "openai",
  },
  strategies = {
    chat = {
      adapter = "openai",
      -- Helpers which can be referenced in the chat buffer with the "@" symbol e.g. "@buffer"
      helpers = {
        ["buffer"] = {
          callback = "helpers.chat.buffer",
          category = "buffer",
          description = "Share the current buffer with the LLM",
        },
        ["buffers"] = {
          callback = "helpers.chat.buffers",
          category = "buffer",
          description = "Share all loaded buffers (matching the filetype) with the LLM",
        },
        -- ["bufferq"] = {
        --   callback = "helpers.chat.bufferq",
        --   category = "buffer",
        --   description = "Share the content of the buffers from the quickfix list",
        -- },
      },
      keymaps = {
        ["<C-s>"] = "keymaps.save",
        ["<C-c>"] = "keymaps.close",
        ["q"] = "keymaps.stop",
        ["gc"] = "keymaps.clear",
        ["ga"] = "keymaps.codeblock",
        ["gs"] = "keymaps.save_chat",
        ["gt"] = "keymaps.add_agent",
        ["]"] = "keymaps.next",
        ["["] = "keymaps.previous",
      },
    },
    inline = {
      adapter = "openai",
      keymaps = {
        ["gc"] = "keymaps.clear_diff",
      },
      prompts = {
        -- The prompt to send to the LLM when a user initiates the inline strategy and it needs to convert to a chat
        inline_to_chat = function(context)
          return "I want you to act as an expert and senior developer in the "
            .. context.filetype
            .. " language. I will ask you questions, perhaps giving you code examples, and I want you to advise me with explanations and code where neccessary."
        end,
      },
    },
    agent = {
      adapter = "openai",
      agents = {
        ["code_runner"] = {
          name = "Code Runner",
          description = "Run code generated by the LLM",
          enabled = true,
        },
        ["rag"] = {
          name = "RAG",
          description = "Supplement the LLM with real-time information",
          enabled = true,
        },
        ["buffer_editor"] = {
          name = "Buffer Editor",
          description = "Edit code by searching and replacing blocks",
          enabled = true,
        },
        ["command_runner"] = {
          name = "Command Runner",
          description = "Run shell commands on the user's system",
          enabled = true,
        },
        opts = {
          auto_submit_errors = false,
          auto_submit_success = false,
        },
      },
    },
  },
  action_prompts = {
    ["Custom Prompt"] = {
      strategy = "inline",
      description = "Send a custom prompt to the LLM",
      opts = {
        index = 1,
        default_prompt = true,
        mapping = "<LocalLeader>cc",
        user_prompt = true,
      },
      prompts = {
        {
          role = "system",
          tag = "system_tag",
          content = function(context)
            if context.buftype == "terminal" then
              return "I want you to act as an expert in writing terminal commands that will work for my current shell "
                .. os.getenv("SHELL")
                .. ". I will ask you specific questions and I want you to return the raw command only (no codeblocks and explanations). If you can't respond with a command, respond with nothing"
            end
            return "I want you to act as a senior "
              .. context.filetype
              .. " developer. I will ask you specific questions and I want you to return raw code only (no codeblocks and no explanations). If you can't respond with code, respond with nothing"
          end,
        },
      },
    },
    ["Senior Developer"] = {
      strategy = "chat",
      name_f = function(context)
        return "Senior " .. utils.capitalize(context.filetype) .. " Developer"
      end,
      description = function(context)
        local filetype
        if context and context.filetype then
          filetype = utils.capitalize(context.filetype)
        end
        return "Chat with a senior " .. (filetype or "") .. " developer"
      end,
      opts = {
        index = 2,
        default_prompt = true,
        modes = { "n", "v" },
        mapping = "<LocalLeader>ce",
        auto_submit = false,
        stop_context_insertion = true,
      },
      prompts = {
        {
          role = "system",
          content = function(context)
            return "I want you to act as an expert and senior developer in the "
              .. context.filetype
              .. " language. I will ask you questions, perhaps giving you code examples, and I want you to advise me with explanations and code where neccessary."
          end,
        },
        {
          role = "user",
          contains_code = true,
          condition = function(context)
            return context.is_visual
          end,
          content = function(context)
            local text = require("codecompanion.helpers.code").get_code(context.start_line, context.end_line)

            return "I have the following code:\n\n```" .. context.filetype .. "\n" .. text .. "\n```\n\n"
          end,
        },
        {
          role = "user",
          condition = function(context)
            return not context.is_visual
          end,
          content = "\n \n",
        },
      },
    },
    ["Code Advisor"] = {
      strategy = "chat",
      description = "Get advice on the code you've selected",
      opts = {
        index = 3,
        default_prompt = true,
        mapping = "<LocalLeader>ca",
        modes = { "v" },
        shortcut = "advisor",
        auto_submit = true,
        user_prompt = true,
        stop_context_insertion = true,
      },
      prompts = {
        {
          role = "system",
          content = function(context)
            return "I want you to act as a senior "
              .. context.filetype
              .. " developer. I will ask you specific questions and I want you to return concise explanations and codeblock examples."
          end,
        },
        {
          role = "user",
          contains_code = true,
          content = function(context)
            local code = require("codecompanion.helpers.code").get_code(context.start_line, context.end_line)

            return "I have the following code:\n\n```" .. context.filetype .. "\n" .. code .. "\n```\n\n"
          end,
        },
      },
    },
    ["Explain LSP Diagnostics"] = {
      strategy = "chat",
      description = "Use an LLM to explain any LSP diagnostics",
      opts = {
        index = 4,
        default_prompt = true,
        mapping = "<LocalLeader>cl",
        modes = { "v" },
        shortcut = "lsp",
        auto_submit = true,
        user_prompt = false, -- Prompt the user for their own input
        stop_context_insertion = true,
      },
      prompts = {
        {
          role = "system",
          content = [[You are an expert coder and helpful assistant who can help debug code diagnostics, such as warning and error messages. When appropriate, give solutions with code snippets as fenced codeblocks with a language identifier to enable syntax highlighting.]],
        },
        {
          role = "user",
          content = function(context)
            local diagnostics =
              require("codecompanion.helpers.lsp").get_diagnostics(context.start_line, context.end_line, context.bufnr)

            local concatenated_diagnostics = ""
            for i, diagnostic in ipairs(diagnostics) do
              concatenated_diagnostics = concatenated_diagnostics
                .. i
                .. ". Issue "
                .. i
                .. "\n  - Location: Line "
                .. diagnostic.line_number
                .. "\n  - Severity: "
                .. diagnostic.severity
                .. "\n  - Message: "
                .. diagnostic.message
                .. "\n"
            end

            return "The programming language is "
              .. context.filetype
              .. ". This is a list of the diagnostic messages:\n\n"
              .. concatenated_diagnostics
          end,
        },
        {
          role = "user",
          contains_code = true,
          content = function(context)
            return "This is the code, for context:\n\n"
              .. "```"
              .. context.filetype
              .. "\n"
              .. require("codecompanion.helpers.code").get_code(
                context.start_line,
                context.end_line,
                { show_line_numbers = true }
              )
              .. "\n```\n\n"
          end,
        },
      },
    },
    ["Generate a Commit Message"] = {
      strategy = "chat",
      description = "Generate a commit message",
      opts = {
        index = 5,
        default_prompt = true,
        mapping = "<LocalLeader>cm",
        shortcut = "commit",
        auto_submit = true,
      },
      prompts = {
        {
          role = "user",
          contains_code = true,
          content = function()
            return "You are an expert at following the Conventional Commit specification. Given the git diff listed below, please generate a commit message for me:"
              .. "\n\n```\n"
              .. vim.fn.system("git diff")
              .. "\n```"
          end,
        },
      },
    },
  },
  display = {
    action_palette = {
      width = 95,
      height = 10,
    },
    chat = {
      window = {
        layout = "vertical", -- float|vertical|horizontal|buffer
        border = "single",
        height = 0.8,
        width = 0.45,
        relative = "editor",
        opts = {
          breakindent = true,
          cursorcolumn = false,
          cursorline = false,
          foldcolumn = "0",
          linebreak = true,
          list = false,
          signcolumn = "no",
          spell = false,
          wrap = true,
        },
      },
      intro_message = "Welcome to CodeCompanion ✨! Save the buffer to send a message...",
      show_settings = true,
      show_token_count = true,
    },
    inline = {
      diff = {
        enabled = true,
        priority = 130,
        hl_groups = {
          removed = "DiffDelete",
        },
      },
    },
  },
  opts = {
    log_level = "ERROR",
    saved_chats_dir = vim.fn.stdpath("data") .. "/codecompanion/saved_chats",
    send_code = true,
    silence_notifications = false,
    use_default_actions = true,
    use_default_prompts = true,
    system_prompt = string.format(
      [[# CodeCompanion AI Assistant

You are an AI programming assistant named "CodeCompanion" integrated into the Neovim text editor. Follow user requirements carefully and precisely. Keep answers concise and professional.

## General Information

- You can answer general programming questions.
- The user works in Neovim version %d.%d.%d.
- Neovim has concepts for editors with open files, integrated unit test support, an output pane for running code, and an integrated terminal.
- The active document is the source code the user is currently viewing.
- You can only give one reply for each conversation turn.
- Use Markdown formatting in your answers, including the programming language name at the start of code blocks.
- Do not wrap the whole response in triple backticks.

## Task Types

### RESPONSE TASKS

These tasks involve direct responses to user queries without executing actions on the user's machine.

Available RESPONSE TASKS:
1. Answer questions about files in the current workspace
2. Explain how selected code works
3. Generate unit tests for selected code
4. Propose fixes for problems in selected code
5. Scaffold code for new features
6. Answer questions about Neovim
7. Explain how to perform terminal actions

For RESPONSE TASKS:
1. Think step-by-step and describe your plan in detailed pseudocode.
2. Output the final code in a single code block.
3. Minimize additional prose.

### COOPERATE TASKS

These tasks involve using agents to perform actions on the user's machine. 

IMPORTANT: Agents are not available by default. You can only use an agent if the user explicitly mentions that it has been granted to you. Do not assume you have access to any agent unless specifically told so.

Potential agents for COOPERATE TASKS (if granted):
1. code_runner: Runs generated code and returns output
2. rag: Supplements responses with real-time information
3. buffer_editor: Modifies existing code or creates new buffers
4. command_runner: Executes terminal commands and provides output

For COOPERATE TASKS (when agents are available):
1. Confirm which agents you have been granted access to.
2. Briefly describe your plan in pseudocode.
3. Write the appropriate agent XML for the available agents.
4. You can return multiple agent XMLs, but explain each one briefly.

## Decision Logic

To determine the appropriate task type:
1. Analyze the user's input carefully.
2. If the user is asking for information, explanations, or code generation without mentioning specific agents or machine actions, treat it as a RESPONSE TASK.
3. If the user explicitly mentions granting access to an agent or requires actions to be performed on their machine, treat it as a COOPERATE TASK. Only use the agents that have been explicitly granted.
4. If unclear or no agents have been granted, default to a RESPONSE TASK. You may suggest the use of agents if you think they would be helpful, but do not attempt to use them unless the user confirms access.

Always ensure you're using the correct response strategy for the identified task type and only use agents when explicitly granted access.]],
      vim.version().major,
      vim.version().minor,
      vim.version().patch
    ),
  },
}
