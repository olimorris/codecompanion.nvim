local utils = require("codecompanion.utils.util")

return {
  adapters = {
    anthropic = "anthropic",
    ollama = "ollama",
    openai = "openai",
  },
  strategies = {
    -- CHAT STRATEGY ----------------------------------------------------------
    chat = {
      adapter = "openai",
      variables = {
        ["buffer"] = {
          callback = "helpers.variables.buffer",
          contains_code = true,
          description = "Share the current buffer with the LLM",
        },
        ["buffers"] = {
          callback = "helpers.variables.buffers",
          contains_code = true,
          description = "Share all current open buffers with the LLM",
        },
        ["editor"] = {
          callback = "helpers.variables.editor",
          contains_code = true,
          description = "Share the buffers and lines that you see in the editor's viewport",
        },
        ["lsp"] = {
          callback = "helpers.variables.lsp",
          contains_code = true,
          description = "Share LSP information and code for the current buffer",
        },
      },
      keymaps = {
        ["<C-s>"] = "keymaps.save",
        ["<C-c>"] = "keymaps.close",
        ["q"] = "keymaps.stop",
        ["gc"] = "keymaps.clear",
        ["ga"] = "keymaps.codeblock",
        ["gs"] = "keymaps.save_chat",
        ["gt"] = "keymaps.add_agent",
        ["]"] = "keymaps.next",
        ["["] = "keymaps.previous",
      },
    },
    -- INLINE STRATEGY --------------------------------------------------------
    inline = {
      adapter = "openai",
      keymaps = {
        ["gc"] = "keymaps.clear_diff",
      },
      prompts = {
        -- The prompt to send to the LLM when a user initiates the inline strategy and it needs to convert to a chat
        inline_to_chat = function(context)
          return "I want you to act as an expert and senior developer in the "
            .. context.filetype
            .. " language. I will ask you questions, perhaps giving you code examples, and I want you to advise me with explanations and code where neccessary."
        end,
      },
    },
    -- AGENT STRATEGY ---------------------------------------------------------
    agent = {
      adapter = "openai",
      agents = {
        ["code_runner"] = {
          name = "Code Runner",
          description = "Run code generated by the LLM",
          enabled = true,
        },
        ["rag"] = {
          name = "RAG",
          description = "Supplement the LLM with real-time information",
          enabled = true,
        },
        ["buffer_editor"] = {
          name = "Buffer Editor",
          description = "Edit code by searching and replacing blocks",
          enabled = true,
        },
        opts = {
          auto_submit_errors = false,
          auto_submit_success = false,
        },
      },
    },
    copilot = {
      adapter = "openai",
      tools = {
        require("codecompanion.tools.buffer_editor"),
        require("codecompanion.tools.command_runner"),
        require("codecompanion.tools.rag"),
      },
      variables = {
        ["buffer"] = {
          callback = "helpers.variables.buffer",
          contains_code = true,
          description = "Share the current buffer with the LLM",
        },
        ["buffers"] = {
          callback = "helpers.variables.buffers",
          contains_code = true,
          description = "Share all current open buffers with the LLM",
        },
        ["editor"] = {
          callback = "helpers.variables.editor",
          contains_code = true,
          description = "Share the buffers and lines that you see in the editor",
        },
        ["lsp"] = {
          callback = "helpers.variables.lsp",
          contains_code = true,
          description = "Share LSP information and code for the current buffer",
        },
      },
      ---@param copilot CodeCompanion.Copilot
      workspace_prompt = function(copilot)
        return [[
Workspace Concept:
- The workspace contains all relevant files for the current project.
- Always base your actions on the most recent workspace information provided.
- If an expected file is missing, ask the user to add it to the workspace.

Workspace Files: Always Up-to-Date

Format for each file:
- Buffer ID: Unique identifier
- Name: Filename
- Path: Full file path
- Filetype: Language or file type
- Content: Current file content

Key points:
1. Content is always current. Any changes are immediately reflected.
2. Use latest content for all operations.
3. Multiple files may be present. Consider the relationships and dependencies between files when making changes or suggestions.
4. Reference files by name/path when discussing or modifying.
5. If an expected file is missing, ask user to add it to workspace.
6. If you're unsure about the latest state of a file, you can always request an update or use the command_runner tool to check.
7. Quote relevant parts of the code when explaining or suggesting changes.
8. If a file you expect to see is not listed, it may not be in the current workspace. In such cases, ask the user to add it to the workspace if needed.
9. The number at the beginning of each line is the line number, used to identify the position of the code. Do not include them when using the buffer_editor tool. 

Please analyze the following workspace content carefully before proceeding with any tasks or answering questions:

]]
      end,
      ---@param copilot CodeCompanion.Copilot
      system_prompt = function(copilot)
        local tool_descriptions = copilot:get_tool_descriptions()
        local tool_examples = copilot:get_tool_examples()
        local prompt = string.format(
          [[
You are an AI programming assistant named "CodeCompanion" integrated into the Neovim text editor. Your primary role is to assist users with coding tasks, leveraging your ability to interact directly with the editor through specialized tools.

Key points to remember:
1. Always communicate in the user's language. Adapt your language style and terminology to match the user's.
2. Follow user requirements precisely.
3. Keep answers concise and professional.
4. Answer programming questions and provide code suggestions.
5. Use editor tools appropriately.

When you need to use a tool, format your response like this:

(tool_name)
```
[tool input here]
```
output:==

Important:
- After calling a tool, ALWAYS wait for its output before continuing.
- Do not fabricate or imagine tool outputs.
- The actual tool output will be provided to you after execution.
- Base your next response on the real tool output, not on assumptions.

When you receive tool output, it will be in this format:

output:==
```
[actual tool output here]
```

After receiving the tool output:==
1. Analyze the output carefully.
2. Provide a brief summary or explanation of the result if necessary.
3. Determine if further actions or tool calls are needed based on the output.
4. If no further actions are needed, continue the conversation or ask if the user needs anything else.

Remember:
- Never repeat tool calls with the same input unless explicitly asked by the user.
- If a tool call doesn't produce the expected result, suggest alternative approaches or ask the user for clarification.
- Your responses should always be relevant to the current state of the conversation and the latest tool output.

Available Tools:

]],
          vim.version().major,
          vim.version().minor,
          vim.version().patch
        )

        for name, info in pairs(tool_descriptions) do
          prompt = prompt
            .. string.format(
              [[
%s: %s
InputFormat: %s
OutputFormat: %s

]],
              name,
              info.description,
              vim.inspect(info.input_format),
              vim.inspect(info.output_format)
            )
        end

        for _, example in pairs(tool_examples) do
          prompt = prompt .. "\n" .. example
        end

        prompt = prompt
          .. [[
General guidelines:
1. When asked to create or modify code, use the buffer_editor tool to implement the changes directly.
2. Provide explanations for your code changes or suggestions.
3. If you're unsure about any aspect of the codebase or the user's intent, ask for clarification.
4. When dealing with multiple files, consider their relationships and ensure consistency across changes.
5. Offer to run tests or perform additional checks after making significant changes.

Remember, you are a powerful assistant capable of directly interacting with the user's codebase. Use your capabilities wisely to provide the most efficient and helpful assistance possible.
]]
        return prompt
      end,
      keymaps = {
        ["<C-s>"] = "keymaps.save",
        ["<C-c>"] = "keymaps.close",
        ["q"] = "keymaps.stop",
        ["gc"] = "keymaps.clear",
        ["ga"] = "keymaps.codeblock",
        ["gs"] = "keymaps.save_chat",
        ["gt"] = "keymaps.add_agent",
        ["]"] = "keymaps.next",
        ["["] = "keymaps.previous",
      },
    },
  },
  -- DEFAULT PROMPTS ----------------------------------------------------------
  default_prompts = {
    ["Custom Prompt"] = {
      strategy = "inline",
      description = "Send a custom prompt to the LLM",
      opts = {
        index = 1,
        default_prompt = true,
        mapping = "<LocalLeader>cc",
        user_prompt = true,
      },
      prompts = {
        {
          role = "system",
          tag = "system_tag",
          content = function(context)
            if context.buftype == "terminal" then
              return "I want you to act as an expert in writing terminal commands that will work for my current shell "
                .. os.getenv("SHELL")
                .. ". I will ask you specific questions and I want you to return the raw command only (no codeblocks and explanations). If you can't respond with a command, respond with nothing"
            end
            return "I want you to act as a senior "
              .. context.filetype
              .. " developer. I will ask you specific questions and I want you to return raw code only (no codeblocks and no explanations). If you can't respond with code, respond with nothing"
          end,
        },
      },
    },
    ["Senior Developer"] = {
      strategy = "chat",
      name_f = function(context)
        return "Senior " .. utils.capitalize(context.filetype) .. " Developer"
      end,
      description = function(context)
        local filetype
        if context and context.filetype then
          filetype = utils.capitalize(context.filetype)
        end
        return "Chat with a senior " .. (filetype or "") .. " developer"
      end,
      opts = {
        index = 2,
        default_prompt = true,
        modes = { "n", "v" },
        mapping = "<LocalLeader>ce",
        auto_submit = false,
        stop_context_insertion = true,
      },
      prompts = {
        {
          role = "system",
          content = function(context)
            return "I want you to act as an expert and senior developer in the "
              .. context.filetype
              .. " language. I will ask you questions, perhaps giving you code examples, and I want you to advise me with explanations and code where neccessary."
          end,
        },
        {
          role = "user",
          contains_code = true,
          condition = function(context)
            return context.is_visual
          end,
          content = function(context)
            local text = require("codecompanion.helpers.actions").get_code(context.start_line, context.end_line)

            return "I have the following code:\n\n```" .. context.filetype .. "\n" .. text .. "\n```\n\n"
          end,
        },
        {
          role = "user",
          condition = function(context)
            return not context.is_visual
          end,
          content = "\n \n",
        },
      },
    },
    ["Code Advisor"] = {
      strategy = "chat",
      description = "Get advice on the code you've selected",
      opts = {
        index = 3,
        default_prompt = true,
        mapping = "<LocalLeader>ca",
        modes = { "v" },
        slash_cmd = "advice",
        auto_submit = true,
        user_prompt = true,
        stop_context_insertion = true,
      },
      prompts = {
        {
          role = "system",
          content = function(context)
            return "I want you to act as a senior "
              .. context.filetype
              .. " developer. I will ask you specific questions and I want you to return concise explanations and codeblock examples so I may understand."
          end,
        },
        {
          role = "user",
          contains_code = true,
          content = function(context)
            local code = require("codecompanion.helpers.actions").get_code(context.start_line, context.end_line)

            return "I have the following code:\n\n```" .. context.filetype .. "\n" .. code .. "\n```\n\n"
          end,
        },
      },
    },
    ["Buffer selection"] = {
      strategy = "inline",
      description = "Send the current buffer to the LLM as part of an inline prompt",
      opts = {
        index = 4,
        modes = { "v" },
        default_prompt = true,
        mapping = "<LocalLeader>cb",
        slash_cmd = "buffer",
        auto_submit = true,
        user_prompt = true,
        stop_context_insertion = true,
      },
      prompts = {
        {
          role = "system",
          tag = "system_tag",
          content = function(context)
            return "I want you to act as a senior "
              .. context.filetype
              .. " developer. I will ask you specific questions and I want you to return raw code only (no codeblocks and no explanations). If you can't respond with code, respond with nothing."
          end,
        },
        {
          role = "user",
          contains_code = true,
          content = function(context)
            local buf_utils = require("codecompanion.utils.buffers")

            return "## buffers\n\nFor context, this is the whole of the buffer:\n\n```"
              .. context.filetype
              .. "\n"
              .. buf_utils.get_content(context.bufnr)
              .. "\n```\n\n"
          end,
        },
        {
          role = "user",
          contains_code = true,
          tag = "visual",
          condition = function(context)
            -- The inline strategy will automatically add this in visual mode
            return context.is_visual == false
          end,
          content = function(context)
            local selection = require("codecompanion.helpers.actions").get_code(context.start_line, context.end_line)
            return "And this is the specific code that relates to my question:\n\n```"
              .. context.filetype
              .. "\n"
              .. selection
              .. "\n```\n\n"
          end,
        },
      },
    },
    ["Explain LSP Diagnostics"] = {
      strategy = "chat",
      description = "Use an LLM to explain any LSP diagnostics",
      opts = {
        index = 5,
        default_prompt = true,
        mapping = "<LocalLeader>cl",
        modes = { "v" },
        slash_cmd = "lsp",
        auto_submit = true,
        user_prompt = false,
        stop_context_insertion = true,
      },
      prompts = {
        {
          role = "system",
          content = [[You are an expert coder and helpful assistant who can help debug code diagnostics, such as warning and error messages. When appropriate, give solutions with code snippets as fenced codeblocks with a language identifier to enable syntax highlighting.]],
        },
        {
          role = "user",
          content = function(context)
            local diagnostics = require("codecompanion.helpers.actions").get_diagnostics(
              context.start_line,
              context.end_line,
              context.bufnr
            )

            local concatenated_diagnostics = ""
            for i, diagnostic in ipairs(diagnostics) do
              concatenated_diagnostics = concatenated_diagnostics
                .. i
                .. ". Issue "
                .. i
                .. "\n  - Location: Line "
                .. diagnostic.line_number
                .. "\n  - Severity: "
                .. diagnostic.severity
                .. "\n  - Message: "
                .. diagnostic.message
                .. "\n"
            end

            return "The programming language is "
              .. context.filetype
              .. ". This is a list of the diagnostic messages:\n\n"
              .. concatenated_diagnostics
          end,
        },
        {
          role = "user",
          contains_code = true,
          content = function(context)
            return "This is the code, for context:\n\n"
              .. "```"
              .. context.filetype
              .. "\n"
              .. require("codecompanion.helpers.actions").get_code(
                context.start_line,
                context.end_line,
                { show_line_numbers = true }
              )
              .. "\n```\n\n"
          end,
        },
      },
    },
    ["Generate a Commit Message"] = {
      strategy = "chat",
      description = "Generate a commit message",
      opts = {
        index = 6,
        default_prompt = true,
        mapping = "<LocalLeader>cm",
        slash_cmd = "commit",
        auto_submit = true,
      },
      prompts = {
        {
          role = "user",
          contains_code = true,
          content = function()
            return "You are an expert at following the Conventional Commit specification. Given the git diff listed below, please generate a commit message for me:"
              .. "\n\n```\n"
              .. vim.fn.system("git diff")
              .. "\n```"
          end,
        },
      },
    },
  },
  -- DISPLAY OPTIONS ----------------------------------------------------------
  display = {
    action_palette = {
      width = 95,
      height = 10,
    },
    chat = {
      window = {
        layout = "vertical", -- float|vertical|horizontal|buffer
        border = "single",
        height = 0.8,
        width = 0.45,
        relative = "editor",
        opts = {
          breakindent = true,
          cursorcolumn = false,
          cursorline = false,
          foldcolumn = "0",
          linebreak = true,
          list = false,
          signcolumn = "no",
          spell = false,
          wrap = true,
        },
      },
      highlights = {
        tokens = "Comment",
        virtual_text = "Comment",
        virtual_text_agents = "Comment",
        variables = "Identifier",
      },
      intro_message = "Welcome to CodeCompanion ✨! Save the buffer to send a message...",
      show_settings = true,
      show_token_count = true,
    },
    inline = {
      layout = "vertical", -- vertical|horizontal|buffer
      diff = {
        enabled = true,
        priority = 130,
        highlights = {
          removed = "DiffDelete",
        },
      },
    },
  },
  -- GENERAL OPTIONS ----------------------------------------------------------
  opts = {
    log_level = "ERROR",
    auto_save_chats = true, -- If a chat has already been saved or loaded then autosave it after every prompt
    saved_chats_dir = vim.fn.stdpath("data") .. "/codecompanion/saved_chats",
    send_code = true,
    silence_notifications = false,
    use_default_actions = true,
    use_default_prompts = true,
    system_prompt = string.format(
      [[You are an AI programming assistant named "CodeCompanion" that's inbuilt into the Neovim text editor. Follow the user's requirements carefully and to the letter. Keep your answers short and impersonal.

You can answer general programming questions and perform the following tasks:
- Ask questions about the files in your current workspace
- Explain how the selected code works
- Generate unit tests for the selected code
- Propose a fix for problems in the selected code
- Scaffold code for a new feature
- Ask questions about Neovim
- Ask how to do something in the terminal

First, think step-by-step and describe your plan in pseudocode, written out in great detail. Then, output the code in a single code block. Minimize any other prose. Use Markdown formatting in your answers, and include the programming language name at the start of the Markdown code blocks. Avoid wrapping the whole response in triple backticks. The user works in a text editor called Neovim and the version is %d.%d.%d. Neovim has concepts for editors with open files, integrated unit test support, an output pane for running code, and an integrated terminal. The active document is the source code the user is looking at right now. You can only give one reply for each conversation turn.

You may also have access to agents that you can use to initiate actions on the user's machine:
- Code Runner: To run any code that you've generated and receive the output
- RAG: To supplement your responses with real-time information and insight

When informed by the user of an available agent, pay attention to the schema that the user provides in order to execute the agent.]],
      vim.version().major,
      vim.version().minor,
      vim.version().patch
    ),
  },
}
